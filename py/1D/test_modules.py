'''Tests of modules in mg-glaciers/py/.  Run as "python3 -m pytest" in current
directory, or via "make test".'''

import numpy as np
from meshlevel import MeshLevel1D
from smoother import PGSPoisson
from siasmoother import PNGSSIA

def test_ml_basics():
    '''Basic MeshLevel1D functionality.'''
    ml = MeshLevel1D(j=2)
    assert ml.m == 7
    assert ml.l2norm(ml.zeros()) == 0.0
    v = ml.zeros()
    assert len(v) == ml.m + 2
    assert (ml.l2norm(ml.xx()) - 1.0 / np.sqrt(2.0)) < 1.0e-10
    f = np.ones(ml.m+2)
    ellcorrect = ml.h * np.array([0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0])
    assert all(ml.ellf(f) == ellcorrect)

def test_ml_cR():
    '''Canonical restriction in MeshLevel1D.'''
    ml = MeshLevel1D(j=1)
    assert ml.m == 3
    assert ml.mcoarser == 1
    r = ml.zeros()
    r[1:4] = 1.0
    assert all(ml.cR(r) == [0.0, 2.0, 0.0])

def test_ml_cP():
    '''Canonical prolongation in MeshLevel1D.'''
    ml = MeshLevel1D(j=1)
    v = np.array([0.0, 1.0, 0.0])
    assert all(ml.cP(v) == [0.0, 0.5, 1.0, 0.5, 0.0])

def test_ml_injectP():
    '''Prolongation of linear functionals by injection in MeshLevel1D.'''
    ml = MeshLevel1D(j=2)
    ell = np.array([0.0, 1.0, 2.0, 3.0, 0.0])
    assert all(ml.injectP(ell) == [0.0, 0.0, 1.0, 0.0, 2.0, 0.0, 3.0, 0.0, 0.0])

def test_ml_mR():
    '''Monotone restriction in MeshLevel1D.'''
    ml = MeshLevel1D(j=2)
    assert ml.m == 7
    v = np.array([0.0, 1.0, 1.0, 0.5, 0.5, 0.5, 0.5, 1.0, 0.0])
    assert all(ml.mR(v) == [0.0, 1.0, 0.5, 1.0, 0.0])
    vback = ml.cP(ml.mR(v))  # note cP uses zero boundary values
    assert all(vback[2:-2] >= v[2:-2])
    assert all(vback[[1, -2]] == [0.5, 0.5])

def test_ml_hierarchy():
    '''For an obstacle phi(x), and defect obstacles generated by monotone
    restriction down the hierarchy,
        chi_J(x) = phi(x),  chi_{j-1}(x) = mR(chi_j(x)),
    show that the increments Phi_j(x) = chi_j(x) - chi_{j-1}(x) add up:
        phi(x) = sum_{j=0}^J Phi_j(x)
    (Interpreting this equation requires canonical prolongation.)
    See bottom equation on page 16 of Graeser & Kornhuber (2009).'''
    ml1 = MeshLevel1D(j=1)
    ml2 = MeshLevel1D(j=2)
    assert ml2.m == 7
    phi = np.array([0.0, 1.0, 2.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0])  # zero b.c.
    assert len(phi) == ml2.m + 2
    chi2 = phi
    chi1 = ml2.mR(chi2)
    chi0 = ml1.mR(chi1)
    assert all(chi1 == [0.0, 2.0, 1.0, 1.0, 0.0])
    assert all(chi0 == [0.0, 2.0, 0.0])
    Psi0 = ml2.cP(ml1.cP(chi0))
    Psi1 = ml2.cP(chi1 - ml1.cP(chi0))
    Psi2 = chi2 - ml2.cP(chi1)
    assert all(Psi0 + Psi1 + Psi2 == phi)

# create a testargs object that mimics args returned by the ArgParse parser
class Namespace:
    '''Dummy class.'''
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

testargs = Namespace(randomseed=1, printwarnings=False)

def test_poisson_pointresidual():
    '''Point-wise residual for Poisson.'''
    ml = MeshLevel1D(j=1)
    prob = PGSPoisson(testargs)
    f = np.array([1.0, 0.5, 0.0, 0.5, 1.0])
    w = f.copy()
    assert prob.pointresidual(ml, w, ml.ellf(f), 1) == - 0.5 * ml.h
    assert prob.pointresidual(ml, w, ml.ellf(f), 2) == - 4.0

def test_poisson_residual():
    '''Residual for Poisson.'''
    ml = MeshLevel1D(j=1)
    prob = PGSPoisson(testargs)
    f = np.array([1.0, 0.5, 0.0, 0.5, 1.0])
    w = f.copy()
    Fcorrect = - np.array([0.0, 0.5*ml.h, 4.0, 0.5*ml.h, 0.0])
    assert all(prob.residual(ml, w, ml.ellf(f)) == Fcorrect)

def test_poisson_pgssweep():
    '''Projected Gauss-Seidel sweep for Poisson.'''
    ml = MeshLevel1D(j=0)
    prob = PGSPoisson(testargs)
    f = np.array([0.0, 1.0, 0.0])
    ell = ml.ellf(f)
    assert all(ell == ml.h * f)
    w = ml.zeros()
    assert all(prob.residual(ml, w, ell) == - ml.h * f)
    phi = np.array([-2.0, -2.0, -2.0])  # thus unconstrained
    prob.smoothersweep(ml, w, ell, phi, omega=1.0, forward=True)
    assert all(prob.residual(ml, w, ell) == ml.zeros())

def test_sia_pointresidual():
    '''Point-wise residual for SIA.'''
    ml = MeshLevel1D(j=1, xmax=1800.0e3)   # note [0,xmax] = [0,1800] km
    prob = PNGSSIA(testargs)
    ml.phi = ml.zeros()                    # attach obstacle to mesh
    f = np.array([-1.0, 0.5, 0.5, 0.5, -1.0]) / prob.secpera
    s = np.array([1.0, 0.5, 0.0, 0.5, 1.0])
    assert np.isreal(prob.pointresidual(ml, s, ml.ellf(f), 1))
    #FIXME assert prob.pointresidual(ml, s, ml.ellf(f), 1) == VALUE

def test_sia_residual():
    '''Residual for SIA.'''
    ml = MeshLevel1D(j=1, xmax=1800.0e3)   # note [0,xmax] = [0,1800] km
    prob = PNGSSIA(testargs)
    ml.phi = ml.zeros()                    # attach obstacle to mesh
    m = np.array([-1.0, 0.5, 0.5, 0.5, -1.0]) / prob.secpera
    s = np.array([0.0, 2500.0, 3100.0, 2500.0, 0.0])  # hand-adjusted so res is small!
    res = prob.residual(ml, s, ml.ellf(m))
    ml.checklen(res)
    assert all(abs(res) < 1.0e-2)

def test_sia_exact():
    '''Exact solution for SIA.'''
    ml = MeshLevel1D(j=2, xmax=1800.0e3)   # note [0,xmax] = [0,1800] km
    prob = PNGSSIA(testargs)
    assert prob.exact_available()
    x = ml.xx()
    b = prob.phi(x)
    m = prob.source(x)
    s = prob.exact(x)
    assert all(b == 0.0)                                   # check flat bed
    assert max(s) == prob.buelerH0                         # check height
    assert max(x[s > 0.0]) - prob.buelerxc < prob.buelerL  # check margin pos
    assert min(m) < 0.0                                    # check mass balance
    assert max(m) > 0.0                                    #   changes sign
    # generate siadatafigure.pdf using j=7 levels above:
    # prob.datafigure(ml)

def test_sia_smoothersweep():
    '''Smoother for SIA.'''
    ml = MeshLevel1D(j=1, xmax=1800.0e3)   # note [0,xmax] = [0,1800] km
    prob = PNGSSIA(testargs)
    ml.phi = ml.zeros()                    # attach obstacle to mesh
    m = np.array([-1.0, 0.5, 0.5, 0.5, -1.0]) / prob.secpera
    s = np.array([0.0, 2500.0, 3100.0, 2500.0, 0.0])  # hand-adjusted so res is small!
    ell = ml.ellf(m)
    res = prob.residual(ml, s, ell)
    prob.smoothersweep(ml, s, ell, ml.phi)
    prob.smoothersweep(ml, s, ell, ml.phi)
    newres = prob.residual(ml, s, ell)
    assert ml.l2norm(newres) < ml.l2norm(res)
