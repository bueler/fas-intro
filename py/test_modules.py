'''Tests of modules in mg-glaciers/py/.  Run as "python3 -m pytest" in current
directory, or via "make test".'''

import numpy as np
from meshlevel import MeshLevel1D
from poisson import pointresidual, residual
from pgs import pgssweep

def test_ml_basics():
    '''Basic MeshLevel1D functionality.'''
    ml = MeshLevel1D(j=2)
    assert ml.m == 7
    assert ml.l2norm(ml.zeros()) == 0.0
    v = ml.zeros()
    assert len(v) == ml.m + 2
    assert (ml.l2norm(ml.xx()) - 1.0 / np.sqrt(2.0)) < 1.0e-10
    f = np.ones(ml.m+2)
    ellcorrect = ml.h * np.array([0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0])
    assert all(ml.ell(f) == ellcorrect)

def test_ml_cR():
    '''Canonical restriction in MeshLevel1D.'''
    ml = MeshLevel1D(j=1)
    assert ml.m == 3
    assert ml.mcoarser == 1
    r = ml.zeros()
    r[1:4] = 1.0
    assert all(ml.cR(r) == [0.0, 2.0, 0.0])

def test_ml_P():
    '''Canonical prolongation in MeshLevel1D.'''
    ml = MeshLevel1D(j=1)
    v = np.array([0.0, 1.0, 0.0])
    assert all(ml.P(v) == [0.0, 0.5, 1.0, 0.5, 0.0])

def test_ml_mR():
    '''Monotone restriction in MeshLevel1D.'''
    ml = MeshLevel1D(j=2)
    assert ml.m == 7
    v = np.array([0.0, 1.0, 1.0, 0.5, 0.5, 0.5, 0.5, 1.0, 0.0])
    assert all(ml.mR(v) == [0.0, 1.0, 0.5, 1.0, 0.0])
    vback = ml.P(ml.mR(v))  # note P uses zero boundary values
    assert all(vback[2:-2] >= v[2:-2])
    assert all(vback[[1, -2]] == [0.5, 0.5])

def test_ml_hierarchy():
    '''For an obstacle phi(x), and defect obstacles generated by monotone
    restriction down the hierarchy,
        chi_J(x) = phi(x),  chi_{j-1}(x) = mR(chi_j(x)),
    show that the increments Phi_j(x) = chi_j(x) - chi_{j-1}(x) add up:
        phi(x) = sum_{j=0}^J Phi_j(x)
    (Interpreting this equation requires canonical prolongation.)
    See bottom equation on page 16 of Graeser & Kornhuber (2009).'''
    ml1 = MeshLevel1D(j=1)
    ml2 = MeshLevel1D(j=2)
    assert ml2.m == 7
    phi = np.array([0.0, 1.0, 2.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0])  # zero b.c.
    assert len(phi) == ml2.m + 2
    chi2 = phi
    chi1 = ml2.mR(chi2)
    chi0 = ml1.mR(chi1)
    assert all(chi1 == [0.0, 2.0, 1.0, 1.0, 0.0])
    assert all(chi0 == [0.0, 2.0, 0.0])
    Psi0 = ml2.P(ml1.P(chi0))
    Psi1 = ml2.P(chi1 - ml1.P(chi0))
    Psi2 = chi2 - ml2.P(chi1)
    assert all(Psi0 + Psi1 + Psi2 == phi)

def test_po_pointresidual():
    '''Point-wise residual for Poisson.'''
    ml = MeshLevel1D(j=1)
    f = np.array([1.0, 0.5, 0.0, 0.5, 1.0])
    w = f.copy()
    assert pointresidual(ml, w, ml.ell(f), 1) == - 0.5 * ml.h
    assert pointresidual(ml, w, ml.ell(f), 2) == - 4.0

def test_po_residual():
    '''Residual for Poisson.'''
    ml = MeshLevel1D(j=1)
    f = np.array([1.0, 0.5, 0.0, 0.5, 1.0])
    w = f.copy()
    Fcorrect = - np.array([0.0, 0.5*ml.h, 4.0, 0.5*ml.h, 0.0])
    assert all(residual(ml, w, ml.ell(f)) == Fcorrect)

def test_pgs_pgssweep1():
    '''Projected Gauss-Seidel sweep.'''
    ml = MeshLevel1D(j=0)
    f = np.array([0.0, 1.0, 0.0])
    ell = ml.ell(f)
    assert all(ell == ml.h * f)
    w = ml.zeros()
    assert all(residual(ml, w, ell) == - ml.h * f)
    phi = np.array([-2.0, -2.0, -2.0])  # thus unconstrained
    pgssweep(ml, w, ell, phi, forward=True)
    assert all(residual(ml, w, ell) == ml.zeros())
